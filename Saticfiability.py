#Let p(i,j,n) denote the proposition that is true when the number n is in the cell in the ith row and the jth column. 

#There are 9×9 × 9 = 729 such propositions. 

#In the sample puzzle p(5,1,6) is true, but p(5,j,6) is false for j = 2,3,...9

#For each cell with a given value, assert p(i,j,n), when the cell in row i and column j has the given value. 

#Assert that every row contains every number. ^ i=1 to 9   ^ n=1 to 9   v j=1 to 9    p(i,j,n)

#Assert that every column contains every number. ^ j=1 to 9   ^ n=1 to 9   v i=1 to 9    p(i,j,n)

#Assert that each of the 3 x 3 blocks contain every number. ^ r=0 to 2   ^ s=0 to 2    ^ n=1 to 9    ^ i=1 to 3    v j=1 to 3 p(3r + i, 3s + j, n)

#Assert that no cell contains more than one number. Take the conjunction over all values of n, n’, i, and j,
#where each variable ranges from 1 to 9 and n!=n', of p(i,j,n) -> not(p(i,j,n')).

#To solve a  Sudoku puzzle, we need to find an assignment of truth values to the 729 variables of the form  p(i,j,n) 
#that makes the conjunction of the assertions true. Those variables that are assigned T yield a solution to the puzzle. 

#A truth table can always be used to determine the satisfiability of a compound proposition. 
#But this is too complex even for modern computers for large problems. 

#There has been much work on developing efficient methods for solving satisfiability problems 
#as many practical problems can be translated into satisfiability problems. 
# import pycosat
import sys, getopt 
import time

def main(argv): 
 
def solve_problem(problemset):
    print('Problem:') 
    pprint(problemset)  
    solve(problemset) 
    print('Answer:')
    pprint(problemset)  
    
def v(i, j, d): 
    return 81 * (i - 1) + 9 * (j - 1) + d

#Reduces Sudoku problem to a SAT clauses 
def sudoku_clauses(): 
    res = []
    # for all cells, ensure that the each cell:
    for i in range(1, 10):
        for j in range(1, 10):
            # denotes (at least) one of the 9 digits (1 clause)
            res.append([v(i, j, d) for d in range(1, 10)])
            # does not denote two different digits at once (36 clauses)
            for d in range(1, 10):
                for dp in range(d + 1, 10):
                    res.append([-v(i, j, d), -v(i, j, dp)])

    def valid(cells): 
        for i, xi in enumerate(cells):
            for j, xj in enumerate(cells):
                if i < j:
                    for d in range(1, 10):
                        res.append([-v(xi[0], xi[1], d), -v(xj[0], xj[1], d)])

    # ensure rows and columns have distinct values
    for i in range(1, 10):
        valid([(i, j) for j in range(1, 10)])
        valid([(j, i) for j in range(1, 10)])
        
    # ensure 3x3 sub-grids "regions" have distinct values
    for i in 1, 4, 7:
        for j in 1, 4 ,7:
            valid([(i + k % 3, j + k // 3) for k in range(9)])
      
    assert len(res) == 81 * (1 + 36) + 27 * 324
    return res

def solve(grid):
    #solve a Sudoku problem
    clauses = sudoku_clauses()
    for i in range(1, 10):
        for j in range(1, 10):
            d = grid[i - 1][j - 1]
            # For each digit already known, a clause (with one literal). 
            if d:
                clauses.append([v(i, j, d)])
    
    # Print number SAT clause  
    numclause = len(clauses)
    print ("P CNF " + str(numclause) +"(number of clauses)")
    
    # solve the SAT problem
    start = time.time()
    sol = set(pycosat.solve(clauses))
    end = time.time()
    print("Time: "+str(end - start))
    
    def read_cell(i, j):
        # return the digit of cell i, j according to the solution
        for d in range(1, 10):
            if v(i, j, d) in sol:
                return d

    for i in range(1, 10):
        for j in range(1, 10):
            grid[i - 1][j - 1] = read_cell(i, j)


if __name__ == '__main__':
    from pprint import pprint

    # Sudoku problem generated by websudoku.com
    sudoku1 = [	[0,0,0,4,0,0,2,0,0],
			[7,0,8,5,2,6,0,9,0],
			[5,0,0,0,1,0,0,0,0],
			[2,3,5,0,0,0,0,0,1],
			[0,0,6,0,7,0,4,0,0],
			[4,0,0,0,0,0,6,3,9],
			[0,0,0,0,3,0,0,0,7],
			[0,6,0,1,5,2,9,0,4],
			[0,0,4,0,0,8,0,0,0]]
	
sudoku2 = [	[0,0,0,0,1,2,8,4,5],
			[0,1,0,7,0,0,0,3,0],
			[0,8,0,6,0,9,0,0,0],
			[2,0,0,0,0,7,4,0,0],
			[0,0,5,0,0,0,9,0,0],
			[0,0,8,9,0,0,0,0,2],
			[0,0,0,1,0,3,0,9,0],
			[0,3,0,0,0,4,0,8,0],
			[1,5,9,2,6,0,0,0,0]]

sudoku3 = [	[9,8,7,0,0,0,3,0,0],
			[1,6,0,0,8,0,0,9,0],
			[0,0,0,0,0,4,1,0,6],
			[0,2,0,0,0,6,0,0,8],
			[0,0,0,5,0,7,0,0,0],
			[3,0,0,9,0,0,0,6,0],
			[2,0,8,4,0,0,0,0,0],
			[0,7,0,0,1,0,0,5,9],
			[0,0,5,0,0,0,8,2,3]]
   